package me.cortex.voxy.client.core.rendering.hierachical;

import it.unimi.dsi.fastutil.ints.IntConsumer;
import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
import it.unimi.dsi.fastutil.ints.IntSet;
import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
import it.unimi.dsi.fastutil.longs.LongSet;
import me.cortex.voxy.client.core.gl.GlBuffer;
import me.cortex.voxy.client.core.rendering.ISectionWatcher;
import me.cortex.voxy.client.core.rendering.building.BuiltSection;
import me.cortex.voxy.client.core.rendering.section.geometry.IGeometryManager;
import me.cortex.voxy.client.core.rendering.util.UploadStream;
import me.cortex.voxy.client.core.util.ExpandingObjectAllocationList;
import me.cortex.voxy.common.Logger;
import me.cortex.voxy.common.util.MemoryBuffer;
import me.cortex.voxy.common.world.WorldEngine;
import org.lwjgl.system.MemoryUtil;

import java.util.List;

import static me.cortex.voxy.common.world.WorldEngine.MAX_LOD_LAYER;
import static me.cortex.voxy.common.world.WorldEngine.UPDATE_TYPE_BLOCK_BIT;


//TODO FIXME: CIRTICAL ISSUE: if a node is a top level section and is empty, when a child is tried to be made it explodes
// since all the children are empty
//  To properly fix this, the top level nodes should only exist if there are non empty children
// (issues related to this fix, lod updates from 0 children state to something children state, aswell as other way round)


public class NodeManager {
    private static final boolean VERIFY_NODE_MANAGER_OPERATIONS = true;//VoxyCommon.isVerificationFlagOn("nodeManager");
    //Assumptions:
    // all nodes have children (i.e. all nodes have at least one child existence bit set at all times)
    // leaf nodes always contain geometry (empty geometry counts as geometry (it just doesnt take any memory to store))
    // All nodes except top nodes have parents

    //NOTE:
    // For the queue processing, will need a redirect node-value type
    //      since for inner node child resize gpu could take N frames to update



    //There is a very funny issue that has kinda, just resolved itself accidentally,
    // however i wonder if i want a better solution for.
    //That issue is, top level nodes that have no children
    // the accidental solution, is that when the node is marked, it generates
    // the child request,
    // however, since there are no children in it, it sticks around, since there isnt anything to update it and invoke
    // the finishRequest on it
    // if the top level node ends up being updated with a child update, it should automatically solve itself
    // as the new children are added to the already inprogress request!!!!






    //Alot of the rules for this datastructure have changed as it has evolved and finished
    // the basic rules are the same, however some may be conditionally broken



    public static final int NULL_GEOMETRY_ID = -1;
    public static final int EMPTY_GEOMETRY_ID = -2;
    public static final int NULL_REQUEST_ID = NodeStore.REQUEST_ID_MSK;
    public static final int SENTINEL_EMPTY_CHILD_PTR = NodeStore.NODE_ID_MSK-1;

    public static final int NODE_ID_MSK = ((1<<24)-1);
    private static final int NODE_TYPE_MSK = 0b11<<30;
    private static final int NODE_TYPE_LEAF = 0b00<<30;
    private static final int NODE_TYPE_INNER = 0b01<<30;
    private static final int NODE_TYPE_REQUEST = 0b10<<30;

    private static final int REQUEST_TYPE_SINGLE = 0b0<<29;
    private static final int REQUEST_TYPE_CHILD = 0b1<<29;
    private static final int REQUEST_TYPE_MSK = 0b1<<29;

    //Single requests are basically _only_ generated by the insertion of top level nodes
    private final ExpandingObjectAllocationList<SingleNodeRequest> singleRequests = new ExpandingObjectAllocationList<>(SingleNodeRequest[]::new);
    private final ExpandingObjectAllocationList<NodeChildRequest> childRequests = new ExpandingObjectAllocationList<>(NodeChildRequest[]::new);
    private final IntOpenHashSet nodeUpdates = new IntOpenHashSet();
    private final IGeometryManager geometryManager;
    private final ISectionWatcher watcher;
    private final Long2IntOpenHashMap activeSectionMap = new Long2IntOpenHashMap();
    private final NodeStore nodeData;
    public final int maxNodeCount;
    private final IntOpenHashSet topLevelNodeIds = new IntOpenHashSet();
    private final LongOpenHashSet topLevelNodes = new LongOpenHashSet();
    private int activeNodeRequestCount;

    private IntConsumer topLevelNodeIdAddedCallback;
    private IntConsumer topLevelNodeIdRemovedCallback;

    public interface ICleaner {
        void alloc(int id);
        void move(int from, int to);
        void free(int id);
    }
    private ICleaner cleanerInterface;
    public void setClear(ICleaner callback) {this.cleanerInterface = callback;}
    private void clearAllocId(int id) { if (this.cleanerInterface != null) this.cleanerInterface.alloc(id); }
    private void clearMoveId(int from, int to) { if (this.cleanerInterface != null) this.cleanerInterface.move(from, to); }
    private void clearFreeId(int id) { if (this.cleanerInterface != null) this.cleanerInterface.free(id); }

    public void setTLNCallbacks(IntConsumer onAdd, IntConsumer onRemove) {
        this.topLevelNodeIdAddedCallback = onAdd;
        this.topLevelNodeIdRemovedCallback = onRemove;
    }

    public NodeManager(int maxNodeCount, IGeometryManager geometryManager, ISectionWatcher watcher) {
        if ((maxNodeCount&(maxNodeCount-1))!=0) {
            throw new IllegalArgumentException("Max node count must be a power of 2");
        }
        if (maxNodeCount>(1<<24)) {
            throw new IllegalArgumentException("Max node count cannot exceed 2^24");
        }
        this.activeSectionMap.defaultReturnValue(-1);
        this.watcher = watcher;
        this.maxNodeCount = maxNodeCount;
        this.nodeData = new NodeStore(maxNodeCount);
        this.geometryManager = geometryManager;
    }

    private static void assertPosValid(long pos) {
        int lvl = WorldEngine.getLevel(pos);
        int x = WorldEngine.getX(pos);
        int y = WorldEngine.getY(pos);
        int z = WorldEngine.getZ(pos);
        if (WorldEngine.getWorldSectionId(lvl, x, y, z) != pos) {
            throw new IllegalStateException("Reconstructed pos not same as original");
        }
        x <<= lvl;
        y <<= lvl;
        z <<= lvl;
        long p2 = WorldEngine.getWorldSectionId(0, x, y, z);
        if (WorldEngine.getLevel(p2) != 0 || WorldEngine.getX(p2) != x || WorldEngine.getY(p2) != y || WorldEngine.getZ(p2) != z) {
            throw new IllegalStateException("Position not valid at all levels: " + pos + "-"+WorldEngine.pprintPos(pos) + ":"+WorldEngine.pprintPos(p2));
        }
    }

    public void insertTopLevelNode(long pos) {
        //Verify that pos is actually valid
        assertPosValid(pos);

        if ((pos&0xF) != 0) {
            throw new IllegalStateException("BAD POS !! YOU DID SOMETHING VERY BAD");
        }
        if (this.activeSectionMap.containsKey(pos)) {
            Logger.error("Tried inserting top level pos " + WorldEngine.pprintPos(pos) + " but it was in active map, discarding!");
            return;
        }

        var request = new SingleNodeRequest(pos);
        int id = this.singleRequests.put(request);
        this.watcher.watch(pos, WorldEngine.DEFAULT_UPDATE_FLAGS);
        this.activeSectionMap.put(pos, id|NODE_TYPE_REQUEST|REQUEST_TYPE_SINGLE);
        this.topLevelNodes.add(pos);
    }

    public void removeTopLevelNode(long pos) {
        if (!this.topLevelNodes.remove(pos)) {
            throw new IllegalStateException("Position not in top level map: " + WorldEngine.pprintPos(pos));
        }
        int nodeId = this.activeSectionMap.get(pos);
        if (nodeId == -1) {
            throw new IllegalStateException("Tried removing top level pos " + WorldEngine.pprintPos(pos) + " but it was not in active map, discarding!");
        }
        if ((nodeId&NODE_TYPE_MSK)!=NODE_TYPE_REQUEST) {
            int id = nodeId&NODE_ID_MSK;
            if (!this.topLevelNodeIds.remove(id)) {
                throw new IllegalStateException("Node id was not in top level node ids: " + nodeId + " pos: " + WorldEngine.pprintPos(pos));
            }
            if (this.topLevelNodeIdRemovedCallback != null)
                this.topLevelNodeIdRemovedCallback.accept(id);
        }
        //Remove the entire thing
        this.recurseRemoveNode(pos);
    }


    IntOpenHashSet getTopLevelNodeIds() {
        return this.topLevelNodeIds;
    }

    //==================================================================================================================

    public void processGeometryResult(BuiltSection sectionResult) {
        long pos = sectionResult.position;
        int nodeId = this.activeSectionMap.get(pos);
        if (nodeId == -1) {
            //Logger.warn("Got geometry update for pos " + WorldEngine.pprintPos(pos) + " but it was not in active map, discarding!");
            sectionResult.free();
            return;
        }

        if ((nodeId&NODE_TYPE_MSK)==NODE_TYPE_REQUEST) {
            //For a request
            if ((nodeId&REQUEST_TYPE_MSK)==REQUEST_TYPE_SINGLE) {
                var request = this.singleRequests.get(nodeId&NODE_ID_MSK);
                request.setMesh(this.uploadReplaceSection(request.getMesh(), sectionResult));

                //sectionResult has a cheeky childExistence field that we can use to set the request too, this is just
                // because processChildChange is only ever invoked when child existence changes, so we still need to
                // populate the request somehow, it will only set it if it hasnt been set before
                if (!request.hasChildExistenceSet()) {
                    request.setChildExistence(sectionResult.childExistence);
                }

                if (request.isSatisfied()) {
                    this.singleRequests.release(nodeId&NODE_ID_MSK);
                    this.finishRequest(request);
                }
            } else if ((nodeId&REQUEST_TYPE_MSK)==REQUEST_TYPE_CHILD) {
                var request = this.childRequests.get(nodeId&NODE_ID_MSK);
                int childId = getChildIdx(pos);
                request.setChildMesh(childId, this.uploadReplaceSection(request.getChildMesh(childId), sectionResult));
                if (!request.hasChildChildExistence(childId)) {
                    request.setChildChildExistence(childId, sectionResult.childExistence);
                }

                if (request.isSatisfied()) {
                    this.finishRequest(nodeId&NODE_ID_MSK, request);
                }
            } else {
                throw new IllegalStateException();
            }
        } else if ((nodeId&NODE_TYPE_MSK)==NODE_TYPE_INNER || (nodeId&NODE_TYPE_MSK)==NODE_TYPE_LEAF) {
            nodeId&=NODE_ID_MSK;


            //TODO: check this is ok and correct
            if ((this.watcher.get(pos)&UPDATE_TYPE_BLOCK_BIT)==0) {
                if (this.nodeData.isNodeGeometryInFlight(nodeId)) {
                    throw new IllegalStateException();
                }
                Logger.warn("Recieved geometry update but not watching it, discarding");
                sectionResult.free();
                return;
            }

            //Unmark geometry inflight
            this.nodeData.unmarkNodeGeometryInFlight(nodeId);
            // Just doing a geometry update
            if (this.updateNodeGeometry(nodeId, sectionResult) != 0) {
                this.invalidateNode(nodeId);
            }
        } else {
            throw new IllegalStateException();
        }
    }

    private void removeGeometryCached(long pos, int id) {
        //Removes geometry possible with downloading to cache
        this.geometryManager.removeSection(id);
    }

    private int uploadReplaceSection(int meshId, BuiltSection section) {
        if (section.isEmpty()) {
            if (meshId != NULL_GEOMETRY_ID && meshId != EMPTY_GEOMETRY_ID) {
                this.geometryManager.removeSection(meshId);
            }
            section.free();
            return EMPTY_GEOMETRY_ID;
        }
        if (meshId != NULL_GEOMETRY_ID && meshId != EMPTY_GEOMETRY_ID) {
            return this.geometryManager.uploadReplaceSection(meshId, section);
        }
        return this.geometryManager.uploadSection(section);
    }

    private int updateNodeGeometry(int node, BuiltSection geometry) {
        int previousGeometry = this.nodeData.getNodeGeometry(node);
        int newGeometry = EMPTY_GEOMETRY_ID;
        if (previousGeometry != EMPTY_GEOMETRY_ID && previousGeometry != NULL_GEOMETRY_ID) {
            if (!geometry.isEmpty()) {
                newGeometry = this.geometryManager.uploadReplaceSection(previousGeometry, geometry);
            } else {
                this.geometryManager.removeSection(previousGeometry);
            }
        } else {
            if (!geometry.isEmpty()) {
                newGeometry = this.geometryManager.uploadSection(geometry);
            }
        }

        if (previousGeometry != newGeometry) {
            this.nodeData.setNodeGeometry(node, newGeometry);
        }
        if (previousGeometry == newGeometry) {
            return 0;//No change
        } else if (previousGeometry == EMPTY_GEOMETRY_ID || previousGeometry == NULL_GEOMETRY_ID) {
            return 1;//Became non-empty/non-null
        } else {
            return 2;//Became empty
        }
    }
    //==================================================================================================================

    public void processChildChange(long pos, byte childExistence) {
        int nodeId = this.activeSectionMap.get(pos);
        if (nodeId == -1) {
            Logger.warn("Got child change for pos " + WorldEngine.pprintPos(pos) + " but it was not in active map, ignoring!");
            return;
        }


        if ((nodeId&NODE_TYPE_MSK)==NODE_TYPE_REQUEST) {
            //For a request
            if ((nodeId&REQUEST_TYPE_MSK)==REQUEST_TYPE_SINGLE) {
                var request = this.singleRequests.get(nodeId&NODE_ID_MSK);
                request.setChildExistence(childExistence);
                if (request.isSatisfied()) {
                    this.singleRequests.release(nodeId&NODE_ID_MSK);
                    this.finishRequest(request);
                }
            } else if ((nodeId&REQUEST_TYPE_MSK)==REQUEST_TYPE_CHILD) {
                var request = this.childRequests.get(nodeId&NODE_ID_MSK);
                request.setChildChildExistence(getChildIdx(pos), childExistence);
                if (request.isSatisfied()) {
                    this.finishRequest(nodeId&NODE_ID_MSK, request);
                }
            } else {
                throw new IllegalStateException();
            }
        } else if ((nodeId&NODE_TYPE_MSK)==NODE_TYPE_INNER) {
            this.updateChildSectionsInner(pos, nodeId&NODE_ID_MSK, childExistence);
        } else if ((nodeId&NODE_TYPE_MSK)==NODE_TYPE_LEAF) {

            //We might be leaf but we still might be inflight
            if (this.nodeData.isNodeRequestInFlight(nodeId&NODE_ID_MSK)) {
                //  Logger.error("UNFINISHED OPERATION TODO: FIXME: painful operation, needs to account for both adding and removing, need to do the same with inner node, but also create requests, or cleanup children");
                int requestId = this.nodeData.getNodeRequest(nodeId);
                var request = this.childRequests.get(requestId);// TODO: do not assume request is childRequest (it will probably always be)
                if (request.getPosition() != pos) throw new IllegalStateException("Request is not at pos, got " + WorldEngine.pprintPos(request.getPosition()) + " expected " + WorldEngine.pprintPos(pos));
                {//Update the request
                    byte oldMsk = request.getMsk();
                    byte change = (byte) (oldMsk ^ childExistence);
                    {//Remove children and free/release associated meshes
                        byte rem = (byte) (change&oldMsk);
                        for (int i = 0; i < 8; i++) {
                            if ((rem&(1<<i))==0) continue;
                            //Remove child geometry and from being watched and activeSections
                            long cPos = makeChildPos(pos, i);

                            int meshId = request.removeAndUnRequire(i);
                            if (meshId != NULL_GEOMETRY_ID && meshId != EMPTY_GEOMETRY_ID) {
                                this.removeGeometryCached(cPos, meshId);
                            }

                            if (this.activeSectionMap.remove(cPos) == -1) {//TODO: verify the removed section is a request type of child and the request id matches this
                                throw new IllegalStateException("Child pos was in a request but not in active section map");
                            }

                            if (!this.watcher.unwatch(cPos, WorldEngine.DEFAULT_UPDATE_FLAGS)) {
                                throw new IllegalStateException("Child pos was not being watched");
                            }
                        }
                    }

                    {//Add new children to the request
                        byte rem = (byte) (change&childExistence);
                        for (int i = 0; i < 8; i++) {
                            if ((rem&(1<<i))==0) continue;
                            //Add child to request
                            request.addChildRequirement(i);

                            //Add child to active tracker and put in updateRouter
                            long cPos = makeChildPos(pos, i);
                            if (this.activeSectionMap.put(cPos, requestId|NODE_TYPE_REQUEST|REQUEST_TYPE_CHILD) != -1) {
                                throw new IllegalStateException("Child pos was already in active section tracker but was part of a request");
                            }
                            if (!this.watcher.watch(cPos, WorldEngine.DEFAULT_UPDATE_FLAGS)) {
                                throw new IllegalStateException("Child pos update router issue");
                            }
                        }
                    }

                    //If the request is now satisfied we need to finish it
                    if (request.isSatisfied()) {
                        this.finishRequest(requestId, request);
                    }
                }
            }

            //Just need to update the child node data, nothing else
            this.nodeData.setNodeChildExistence(nodeId&NODE_ID_MSK, childExistence);
            //Need to resubmit to gpu
            this.invalidateNode(nodeId&NODE_ID_MSK);//TODO:FIXME: Do we???
        }
    }

    private void updateChildSectionsInner(long pos, int nodeId, byte childExistence) {
        //Very complex and painful operation

        if (childExistence == 0) {
            Logger.warn("Inner node child existence is changing to 0, this is mild bad");
        }

        //This works in 2 parts, adding and removing, adding is (surprisingly) much easier than removing
        // adding, either adds to a request, or creates a new request
        byte existence = this.nodeData.getNodeChildExistence(nodeId);

        byte add = (byte) ((existence^childExistence)&childExistence);
        if (add != 0) {//We have nodes to add
            if (!this.nodeData.isNodeRequestInFlight(nodeId)) {//If there is not an existing request, create it
                var request = new NodeChildRequest(pos);
                int requestId = this.childRequests.put(request);

                this.nodeData.markRequestInFlight(nodeId);
                this.nodeData.setNodeRequest(nodeId, requestId);
                this.activeNodeRequestCount++;
            }
            //It is guaranteed that at this point the node has a request
            // so add the new nodes to it
            int requestId = this.nodeData.getNodeRequest(nodeId);
            var request = this.childRequests.get(requestId);// TODO: do not assume request is childRequest (it will probably always be)
            if (request.getPosition() != pos) throw new IllegalStateException("Request is not at pos: got " + WorldEngine.pprintPos(pos) + " expected: " + WorldEngine.pprintPos(request.getPosition()));

            //Add all new children to the request
            for (int i = 0; i < 8; i++) {
                if ((add&(1<<i))==0) continue;
                //Add child to request
                request.addChildRequirement(i);
                //Add child to active tracker and put in updateRouter
                long cPos = makeChildPos(pos, i);
                if (this.activeSectionMap.put(cPos, requestId|NODE_TYPE_REQUEST|REQUEST_TYPE_CHILD) != -1) {
                    throw new IllegalStateException("Child pos was already in active section tracker but was part of a request");
                }
                if (!this.watcher.watch(cPos, WorldEngine.DEFAULT_UPDATE_FLAGS)) {
                    throw new IllegalStateException("Child pos update router issue");
                }
            }
        }

        //Update the nodes existence msk to the new one
        // this needs to be before the removal since that may invoke requestFinish, which expects updated node masks
        //TODO: verify this
        this.nodeData.setNodeChildExistence(nodeId, childExistence);

        // Do removals
        int rem = ((existence^childExistence)&existence)&0xFF;
        if (rem != 0) {
            //If there is an inflight request, update it w.r.t removals
            if (this.nodeData.isNodeRequestInFlight(nodeId)) {
                int requestId = this.nodeData.getNodeRequest(nodeId);
                var request = this.childRequests.get(requestId);// TODO: do not assume request is childRequest (it will probably always be)
                if (request.getPosition() != pos) throw new IllegalStateException("Request is not at pos");


                int reqRem =Byte.toUnsignedInt(request.getMsk())&rem;
                if (reqRem != 0) {
                    //There are things in the request to remove
                    for (int i = 0; i < 8; i++) {
                        if ((reqRem & (1 << i)) == 0) continue;

                        //Remove child geometry and from being watched and activeSections
                        long cPos = makeChildPos(pos, i);

                        int meshId = request.removeAndUnRequire(i);
                        if (meshId != NULL_GEOMETRY_ID && meshId != EMPTY_GEOMETRY_ID) {
                            this.removeGeometryCached(cPos, meshId);
                        }

                        int cnid = this.activeSectionMap.remove(cPos);
                        if (cnid == -1 || (cnid&NODE_TYPE_MSK) != NODE_TYPE_REQUEST) {//TODO: verify the removed section is a request type of child and the request id matches this
                            throw new IllegalStateException("Child pos was in a request but not in active section map");
                        }
                        if (!this.watcher.unwatch(cPos, WorldEngine.DEFAULT_UPDATE_FLAGS)) {
                            throw new IllegalStateException("Child pos was not being watched");
                        }
                    }
                }
                rem ^= reqRem;
            }

            if (rem != 0) {
                //There are child node entries that need removing
                // and of course still delete all the old data



                //Compact the node data with respect to what has been removed
                int oldPtr = this.nodeData.getChildPtr(nodeId);
                int oldCount = this.nodeData.getChildPtrCount(nodeId);
                if (oldPtr == -1) {
                    throw new IllegalStateException();
                }
                int oldExistence = 0;
                for (int i = 0; i < oldCount; i++) {
                    if (!this.nodeData.nodeExists(i+oldPtr)) throw new IllegalStateException();
                    oldExistence |= 1<<getChildIdx(this.nodeData.nodePosition(i+oldPtr));
                }

                if ((rem&oldExistence)!=rem) {//If rem contains stuff that does not exist, is illegal
                    throw new IllegalStateException();
                }

                int remaining = rem^oldExistence;

                if (remaining == 0) {
                    //This state should only ever occur when a node is inflight, or... if an inner node has existance mask of 0... sigh
                    if (childExistence != 0 && !this.nodeData.isNodeRequestInFlight(nodeId)) {
                        throw new IllegalStateException();
                    }
                    //TODO: TRIPPLY CHECK THIS IS RIGHT
                    //TODO: make new SENTINAL value for this!!! NodeStore.NODE_ID_MSK-1
                    // check in shader aswell!!!

                    this.nodeData.setAllChildrenAreLeaf(nodeId, false);//Children dont exist, therefor set them to false
                    this.nodeData.setChildPtr(nodeId, SENTINEL_EMPTY_CHILD_PTR);
                    this.nodeData.setChildPtrCount(nodeId, 8);
                    for (int i = 0; i < 8; i++) {
                        if ((rem&(1<<i))==0) continue;
                        long cPos = makeChildPos(pos, i);
                        this.recurseRemoveNode(cPos);
                    }
                    //this.nodeData.free(oldPtr, oldCount);

                } else {

                    int newCnt = Integer.bitCount(remaining);
                    int newPtr = this.nodeData.allocate(newCnt);
                    int prevChildId = oldPtr - 1;
                    int newChildId = newPtr - 1;

                    boolean allChildNodesLeaf = true;
                    //Need to compact the old into the new
                    for (int i = 0; i < 8; i++) {
                        if ((oldExistence & (1 << i)) == 0) continue;
                        prevChildId++;
                        if ((rem & (1 << i)) != 0) {//If we removing
                            long cPos = makeChildPos(pos, i);
                            this.recurseRemoveNode(cPos);
                        } else {//We are compacting
                            newChildId++;
                            long cPos = this.nodeData.nodePosition(prevChildId);
                            if (cPos != makeChildPos(pos, i)) {
                                throw new IllegalStateException();
                            }

                            //copy the previous entry to its new location
                            this.nodeData.copyNode(prevChildId, newChildId);

                            this.clearAllocId(newChildId);
                            this.clearMoveId(prevChildId, newChildId);
                            this.clearFreeId(prevChildId);

                            int prevNodeId = this.activeSectionMap.get(cPos);
                            if ((prevNodeId & NODE_TYPE_MSK) == NODE_TYPE_REQUEST) {
                                throw new IllegalStateException();
                            }
                            if ((prevNodeId & NODE_ID_MSK) != prevChildId) {
                                throw new IllegalStateException("State inconsistency");
                            }
                            allChildNodesLeaf &= (prevNodeId & NODE_TYPE_MSK) == NODE_TYPE_LEAF;
                            this.activeSectionMap.put(cPos, (prevNodeId & NODE_TYPE_MSK) | newChildId);

                            //Release the old entry
                            this.nodeData.free(prevChildId);
                            //Need to invalidate the old and the new
                            this.invalidateNode(prevChildId);
                            this.invalidateNode(newChildId);
                        }
                    }
                    this.nodeData.setAllChildrenAreLeaf(nodeId, allChildNodesLeaf);

                    //Put the new childPtr into the map
                    this.nodeData.setChildPtr(nodeId, newPtr);
                    this.nodeData.setChildPtrCount(nodeId, newCnt);

                    if (VERIFY_NODE_MANAGER_OPERATIONS) {
                        //Verify all old is free
                        for (int i = 0; i < oldCount; i++) {
                            if (this.nodeData.nodeExists(i + oldPtr)) {
                                throw new IllegalStateException();
                            }
                        }
                    }
                }

                //Invalidate the node as data has changed
                this.invalidateNode(nodeId);
            }

            //TODO: reuse requestId and obj from before (its faster)
            //Only finish the request after so that compaction of the child msk is correct
            if (this.nodeData.isNodeRequestInFlight(nodeId)) {//Also only need to do this after/if there are removals to be done
                int requestId = this.nodeData.getNodeRequest(nodeId);
                var request = this.childRequests.get(requestId);// TODO: do not assume request is childRequest (it will probably always be)
                if (request.getPosition() != pos) throw new IllegalStateException("Request is not at pos");

                if (request.isSatisfied()) {
                    this.finishRequest(requestId, request);
                }
            }
        }


        if (childExistence == 0) {
            //We need to change the node from inner to leaf as it does not have any children
            if (this.nodeData.isNodeRequestInFlight(nodeId))//Leaf nodes cannot have requests associated to them
                throw new IllegalStateException();

            if (this.nodeData.getNodeGeometry(nodeId) == NULL_GEOMETRY_ID) {
                //throw new IllegalStateException("leaf nodes must have geometry");
                Logger.error("Transforming inner node to leaf node while it has null geometry");
                if (!this.nodeData.isNodeGeometryInFlight(nodeId)) {
                    if ((this.watcher.get(pos) & UPDATE_TYPE_BLOCK_BIT) != 0) {
                        throw new IllegalStateException("Watcher was already watching for geometry update, but geometry was null");
                    }
                    this.processRequest(pos);//Force geometry request
                    if (((this.watcher.get(pos) & UPDATE_TYPE_BLOCK_BIT) == 0)||!this.nodeData.isNodeGeometryInFlight(nodeId)) {
                        throw new IllegalStateException("Watcher must be watching for geometry update");
                    }
                }
                //Set the geometry to EMPTY while the geometry update request is executing
                //throw new IllegalStateException();
                Logger.error("Setting geometry to EMPTY while request is inflight");
                //TODO: figure out a better way to mark this for tracing verificaction and like less confusion
                // (instead of like EMPTY_GEOMETRY_ID do like INFLIGHT_GEOMETRY_ID)
                this.nodeData.setNodeGeometry(nodeId, EMPTY_GEOMETRY_ID);
            }

            if (this.nodeData.getChildPtr(nodeId) != SENTINEL_EMPTY_CHILD_PTR) {//This should only ever be the sentinal ptr
                throw new IllegalStateException();
            }

            this.nodeData.setChildPtr(nodeId, -1);
            int old = this.activeSectionMap.put(pos, NODE_TYPE_LEAF|nodeId);
            this.nodeData.setAllChildrenAreLeaf(nodeId, false);//Node is leaf so is not all child leaf
            this.invalidateNode(nodeId);
        }
    }

    private void recurseRemoveChildNodes(long pos) {
        this._recurseRemoveNode(pos, true);
    }

    private void recurseRemoveNode(long pos) {
        this._recurseRemoveNode(pos, false);
    }


    private void _removeRequest(int reqId, NodeChildRequest req, long pos) {
        //Delete all the request data
        for (int i = 0; i < 8; i++) {
            if ((req.getMsk()&(1<<i))==0) continue;

            //Unwatch the request position
            long childPos = makeChildPos(pos, i);

            int meshId = req.getChildMesh(i);
            if (meshId != EMPTY_GEOMETRY_ID && meshId != NULL_GEOMETRY_ID)
                this.removeGeometryCached(childPos, meshId);

            //Remove from section tracker
            int cId = this.activeSectionMap.remove(childPos);
            if (cId == -1) {
                throw new IllegalStateException("Child not in activeMap");
            }
            if ((cId&NODE_TYPE_MSK) != NODE_TYPE_REQUEST || (cId&REQUEST_TYPE_MSK) != REQUEST_TYPE_CHILD || (cId&NODE_ID_MSK) != reqId) {
                throw new IllegalStateException("Invalid child active state map: " + cId);
            }
            if (!this.watcher.unwatch(childPos, WorldEngine.DEFAULT_UPDATE_FLAGS)) {
                throw new IllegalStateException("Pos was not being watched");
            }
        }

        this.childRequests.release(reqId);//Release the request
        this.activeNodeRequestCount--;
    }

    //Recursivly fully removes all nodes and children
    private void _recurseRemoveNode(long pos, boolean onlyRemoveChildren) {
        //NOTE: this also removes from the section map
        int nodeId;
        if (onlyRemoveChildren) {
            nodeId = this.activeSectionMap.get(pos);
        } else {
            nodeId = this.activeSectionMap.remove(pos);
        }
        if (nodeId == -1) {
            throw new IllegalStateException("Cannot remove pos that doesnt exist");
        }
        int type = nodeId&NODE_TYPE_MSK;
        if (type == NODE_TYPE_INNER || type == NODE_TYPE_LEAF) {
            nodeId &= NODE_ID_MSK;
            if (!this.nodeData.nodeExists(nodeId)) {
                throw new IllegalStateException("Node exists in section map but not in nodeData");
            }


            byte childExistence = this.nodeData.getNodeChildExistence(nodeId);
            if (this.nodeData.isNodeRequestInFlight(nodeId)) {
                //If there is an inflight request, the request and all associated data
                int reqId = this.nodeData.getNodeRequest(nodeId);
                //TODO: Dont assume this can only be a child request

                var req = this.childRequests.get(reqId);
                childExistence ^= req.getMsk();

                this._removeRequest(reqId, req, pos);

                if (onlyRemoveChildren) {
                    this.nodeData.unmarkRequestInFlight(nodeId);
                    this.nodeData.setNodeRequest(nodeId, NULL_REQUEST_ID);
                }
            }


            //Need to recurse into childExistence that exist, this is xor between a request mask if there is and the
            // childRequest
            // this is only valid if this node is an inner node

            //Only recursively delete if the node is not a leaf
            if (type == NODE_TYPE_INNER) {
                //Verify child data
                if (VERIFY_NODE_MANAGER_OPERATIONS) {
                    byte msk = 0;
                    int childPtr = this.nodeData.getChildPtr(nodeId);
                    if (childPtr == -1) {
                        throw new IllegalStateException();
                    }
                    if (childPtr != SENTINEL_EMPTY_CHILD_PTR) {
                        int childCnt = this.nodeData.getChildPtrCount(nodeId);
                        if (Integer.bitCount(Byte.toUnsignedInt(childExistence)) != childCnt) {
                            throw new IllegalStateException();
                        }
                        for (int i = 0; i < childCnt; i++) {
                            if (!this.nodeData.nodeExists(i + childPtr)) {
                                throw new IllegalStateException();
                            }
                            long cp = this.nodeData.nodePosition(i + childPtr);
                            if (makeParentPos(cp) != pos) {
                                throw new IllegalStateException();
                            }
                            msk |= (byte) (1 << getChildIdx(cp));
                        }
                    }
                    if (msk != childExistence) {
                        throw new IllegalStateException();
                    }
                }

                for (int i = 0; i < 8; i++) {
                    if ((childExistence & (1 << i)) == 0) continue;

                    long childPos = makeChildPos(pos, i);
                    this.recurseRemoveNode(childPos);
                }

                //Verify that all node children are free
                if (VERIFY_NODE_MANAGER_OPERATIONS) {
                    int childPtr = this.nodeData.getChildPtr(nodeId);
                    if (childPtr == -1) {
                        throw new IllegalStateException();
                    }
                    if (childPtr != SENTINEL_EMPTY_CHILD_PTR) {
                        int childCnt = this.nodeData.getChildPtrCount(nodeId);
                        if (Integer.bitCount(Byte.toUnsignedInt(childExistence)) != childCnt) {
                            throw new IllegalStateException();
                        }
                        for (int i = 0; i < childCnt; i++) {
                            if (this.nodeData.nodeExists(i+childPtr)) {
                                throw new IllegalStateException();
                            }
                        }
                    }
                }
                if (onlyRemoveChildren) {
                    this.nodeData.setChildPtr(nodeId, -1);
                }
            }

            if (!onlyRemoveChildren) {
                //Free geometry and related memory for this node
                int meshId = this.nodeData.getNodeGeometry(nodeId);
                if (meshId != EMPTY_GEOMETRY_ID && meshId != NULL_GEOMETRY_ID)
                    this.removeGeometryCached(pos, meshId);

                this.nodeData.free(nodeId);
                this.clearFreeId(nodeId);
                this.invalidateNode(nodeId);

                //Unwatch position
                if (!this.watcher.unwatch(pos, WorldEngine.DEFAULT_UPDATE_FLAGS)) {
                    throw new IllegalStateException("Pos was not being watched");
                }
            } else {
                //All children removed, clear marker
                this.nodeData.setAllChildrenAreLeaf(nodeId, false);
                //TODO: probably need this.clearId(nodeId);
                this.invalidateNode(nodeId);
            }
        } else if (type == NODE_TYPE_REQUEST) {
            if (!this.watcher.unwatch(pos, WorldEngine.DEFAULT_UPDATE_FLAGS)) {
                throw new IllegalStateException("Pos was not being watched");
            }
            if ((nodeId&REQUEST_TYPE_MSK) == REQUEST_TYPE_SINGLE) {
                nodeId &= NODE_ID_MSK;

                var req = this.singleRequests.get(nodeId);
                if (req.getPosition() != pos)
                    throw new IllegalStateException();

                this.singleRequests.release(nodeId);
                if (req.hasMeshSet()) {
                    int meshId = req.getMesh();
                    if (meshId != EMPTY_GEOMETRY_ID && meshId != NULL_GEOMETRY_ID)
                        this.removeGeometryCached(pos, meshId);
                }

            } else {
                nodeId &= NODE_ID_MSK;
                var req = this.childRequests.get(nodeId);
                if (req.getPosition() != pos)
                    throw new IllegalStateException();
                this._removeRequest(nodeId, req, pos);
            }
        } else {
            throw new IllegalStateException();
        }
    }

    //==================================================================================================================

    private void finishRequest(SingleNodeRequest request) {
        int id = this.nodeData.allocate();
        this.nodeData.setNodePosition(id, request.getPosition());
        this.nodeData.setNodeGeometry(id, request.getMesh());
        this.nodeData.setNodeChildExistence(id, request.getChildExistence());
        //TODO: this (or remove)
        //this.nodeData.setNodeType();
        this.activeSectionMap.put(request.getPosition(), id|NODE_TYPE_LEAF);//Assume that the result of any single request type is a leaf node
        this.invalidateNode(id);


        //Assume that this is always a top node
        // FIXME: DONT DO THIS
        if (!this.topLevelNodeIds.add(id)) {
            throw new IllegalStateException();
        }
        this.clearAllocId(id);
        if (this.topLevelNodeIdAddedCallback != null)
            this.topLevelNodeIdAddedCallback.accept(id);
    }

    private void finishRequest(int requestId, NodeChildRequest request) {
        int parentNodeId = this.activeSectionMap.get(request.getPosition());
        if (parentNodeId == -1 || (parentNodeId&NODE_TYPE_MSK)==NODE_TYPE_REQUEST) {
            throw new IllegalStateException("CRITICAL BAD STATE!!! finishRequest tried to finish for a node that no longer exists in the map or has become a request type somehow?!!?!!" + WorldEngine.pprintPos(request.getPosition()) + " " + parentNodeId);
        }
        int parentNodeType = parentNodeId&NODE_TYPE_MSK;
        parentNodeId &= NODE_ID_MSK;

        if (request.getMsk() == 0) {
            //Request was "canceled" so remove the request

            //Free request
            this.childRequests.release(requestId);

            //Update the parent
            this.nodeData.setNodeRequest(parentNodeId, NULL_REQUEST_ID);
            this.nodeData.unmarkRequestInFlight(parentNodeId);
            this.activeNodeRequestCount--;

            //Invalidate parent
            this.invalidateNode(parentNodeId);

            //TODO: verify things here
            return;
        }
        if (parentNodeType==NODE_TYPE_LEAF) {
            int msk = Byte.toUnsignedInt(request.getMsk());
            if (msk == 0) {
                throw new IllegalStateException();
            }
            int base = this.nodeData.allocate(Integer.bitCount(msk));
            int offset = -1;
            for (int childIdx = 0; childIdx < 8; childIdx++) {
                if ((msk&(1<<childIdx)) == 0) {
                    continue;
                }
                offset++;

                long childPos = makeChildPos(request.getPosition(), childIdx);
                int childNodeId = base+offset;
                //Fill in node
                this.nodeData.setNodePosition(childNodeId, childPos);
                byte childExistence = request.getChildChildExistence(childIdx);
                if (childExistence == 0) {
                    //This is an ok error if it happens the request with a child state should never be zero


                    //TODO: make into warning or log error
                    //throw new IllegalStateException("Request result with child existence of 0");

                }
                this.nodeData.setNodeChildExistence(childNodeId, childExistence);
                this.nodeData.setNodeGeometry(childNodeId, request.getChildMesh(childIdx));
                //Mark for update
                this.invalidateNode(childNodeId);
                //this.clearId(childNodeId);//Clear the id

                //Put in map
                int pid = this.activeSectionMap.put(childPos, childNodeId|NODE_TYPE_LEAF);
                if ((pid&NODE_TYPE_MSK) != NODE_TYPE_REQUEST) {
                    throw new IllegalStateException("Put node in map from request but type was not request: " + pid + " " + WorldEngine.pprintPos(childPos));
                }

                this.clearAllocId(childNodeId);
            }
            //Free request
            this.childRequests.release(requestId);
            //Update the parent
            this.nodeData.setChildPtr(parentNodeId, base);
            this.nodeData.setChildPtrCount(parentNodeId, Integer.bitCount(msk));
            this.nodeData.setNodeRequest(parentNodeId, NULL_REQUEST_ID);
            this.activeNodeRequestCount--;
            this.nodeData.unmarkRequestInFlight(parentNodeId);

            //Change it from a leaf to an inner node
            //Set the type from leaf to inner node
            if ((this.activeSectionMap.put(request.getPosition(), NODE_TYPE_INNER|parentNodeId)&NODE_TYPE_MSK)!=NODE_TYPE_LEAF) {
                throw new IllegalStateException();
            }
            this.invalidateNode(parentNodeId);
            this.nodeData.setAllChildrenAreLeaf(parentNodeId, true);

            //TODO: Need to set AllChildrenAreLeaf of the parent of the parent to false
            //Update the parentParent that all the children are leaf
            if (!this.topLevelNodes.contains(request.getPosition())) {
                int ppnId = this.activeSectionMap.get(makeParentPos(request.getPosition()));
                if ((ppnId&NODE_TYPE_MSK) != NODE_TYPE_INNER) {
                    throw new IllegalStateException();
                }
                //Since this node isnt a leaf node anymore
                this.nodeData.setAllChildrenAreLeaf(ppnId&NODE_ID_MSK, false);
            }
        } else if (parentNodeType==NODE_TYPE_INNER) {
            //For this, only need to add the nodes to the existing child set thing (shuffle around whatever) dont ever have to remove nodes

            int oldChildPtr = this.nodeData.getChildPtr(parentNodeId);
            int oldChildCnt = this.nodeData.getChildPtrCount(parentNodeId);
            if (oldChildPtr == -1) {
                throw new IllegalStateException();
            }

            int existingChildMsk = 0;

            //If the pointer is the empty ptr, dont check the count
            if (oldChildPtr != SENTINEL_EMPTY_CHILD_PTR) {
                //Ok so technically, it _is ok_ to just add to the end of the childPtr, however, imo that is stupid
                // and it should follow the logical allocation with respect to the 8 child indices
                // this means, need to extract the child indices already in the ptr (or technically could use the child existance? but having both and doing verification would be good)

                for (int i = 0; i < oldChildCnt; i++) {
                    if (!this.nodeData.nodeExists(i + oldChildPtr)) {
                        throw new IllegalStateException();
                    }
                    existingChildMsk |= 1 << getChildIdx(this.nodeData.nodePosition(i + oldChildPtr));
                }
            }
            int reqMsk = Byte.toUnsignedInt(request.getMsk());
            if ((byte) (existingChildMsk|reqMsk) != this.nodeData.getNodeChildExistence(parentNodeId)) {
                //System.out.println(Integer.toBinaryString(Byte.toUnsignedInt(this.nodeData.getNodeChildExistence(parentNodeId))));System.out.println(Integer.toBinaryString(existingChildMsk));System.out.println(Integer.toBinaryString(reqMsk));
                    throw new IllegalStateException("node data existence state does not match pointer mask");
            }


            if ((reqMsk&existingChildMsk)!=0) {
                throw new IllegalStateException("Overlapping child data!!! BAD");
            }

            //Create the new allocation
            int newMsk = reqMsk | existingChildMsk;
            int newChildPtr = this.nodeData.allocate(Integer.bitCount(newMsk));

            //Need to interlace the old and new data into the new allocation
            // FOR OLD ALLOCATIONS, NEED TO UPDATE POINTERS
            int childId = newChildPtr-1;
            int prevChildId = oldChildPtr-1;

            for (int i = 0; i < 8; i++) {
                if ((newMsk&(1<<i))==0) continue;
                childId++;

                if ((reqMsk&(1<<i))!=0) {

                    //Its an entry from the request
                    long childPos = makeChildPos(request.getPosition(), i);

                    this.nodeData.setNodePosition(childId, childPos);
                    byte childExistence = request.getChildChildExistence(i);
                    if (childExistence == 0) {

                        //TODO: make into warning or log error
                        //throw new IllegalStateException("Request result with child existence of 0");


                    }
                    this.nodeData.setNodeChildExistence(childId, childExistence);
                    this.nodeData.setNodeGeometry(childId, request.getChildMesh(i));

                    //Mark for update
                    this.invalidateNode(childId);

                    //Put in map
                    int pid = this.activeSectionMap.put(childPos, childId|NODE_TYPE_LEAF);
                    if ((pid&NODE_TYPE_MSK) != NODE_TYPE_REQUEST) {
                        throw new IllegalStateException("Put node in map from request but type was not request: " + pid + " " + WorldEngine.pprintPos(childPos));
                    }
                    this.clearAllocId(childId);
                } else {
                    prevChildId++;

                    long pos = this.nodeData.nodePosition(prevChildId);

                    //Its a previous entry, copy it to its new location
                    this.nodeData.copyNode(prevChildId, childId);

                    this.clearAllocId(childId);
                    this.clearMoveId(prevChildId, childId);
                    this.clearFreeId(prevChildId);

                    int prevNodeId = this.activeSectionMap.get(pos);
                    if ((prevNodeId&NODE_TYPE_MSK) == NODE_TYPE_REQUEST) {
                        throw new IllegalStateException();
                    }
                    if ((prevNodeId&NODE_ID_MSK) != prevChildId) {
                        throw new IllegalStateException("State inconsistency");
                    }
                    this.activeSectionMap.put(pos, (prevNodeId&NODE_TYPE_MSK)|childId);
                    //Need to invalidate the old and the new
                    this.invalidateNode(prevChildId);
                    this.invalidateNode(childId);
                }
            }

            //Do final steps

            //Free the old child data
            if (oldChildPtr != SENTINEL_EMPTY_CHILD_PTR) {
                this.nodeData.free(oldChildPtr, oldChildCnt);
            }

            //If the old ptr was sentinal null, this node is now pure leaf children
            if (oldChildPtr == SENTINEL_EMPTY_CHILD_PTR) {
                this.nodeData.setAllChildrenAreLeaf(parentNodeId, true);
            }

            //Free request
            this.childRequests.release(requestId);

            //Update the parent
            this.nodeData.setChildPtr(parentNodeId, newChildPtr);
            this.nodeData.setChildPtrCount(parentNodeId, Integer.bitCount(newMsk));
            this.nodeData.setNodeRequest(parentNodeId, NULL_REQUEST_ID);
            this.activeNodeRequestCount--;
            this.nodeData.unmarkRequestInFlight(parentNodeId);

            //Invalidate parent
            this.invalidateNode(parentNodeId);
        } else {
            throw new IllegalStateException();
        }
    }

    //==================================================================================================================
    public void processRequest(long pos) {
        int nodeId = this.activeSectionMap.get(pos);
        if (nodeId == -1) {
            //TODO: make into timing thing
            //Logger.warn("Got request for pos " + WorldEngine.pprintPos(pos) + " but it was not in active map, ignoring!");
            return;
        }
        int nodeType = nodeId&NODE_TYPE_MSK;
        nodeId &= NODE_ID_MSK;
        if (nodeType == NODE_TYPE_REQUEST) {
            Logger.error("Tried processing request for pos: " + WorldEngine.pprintPos(pos) + " but its type was a request, ignoring!");
            return;
        } else if (nodeType != NODE_TYPE_LEAF && nodeType != NODE_TYPE_INNER ) {
            throw new IllegalStateException("Unknown node type: " + nodeType);
        }


        if (WorldEngine.getLevel(pos) == 0) {
            Logger.error("Requests cannot exist for bottom level nodes. at: " + WorldEngine.pprintPos(pos) + ". Ignoring request");
            return;
        }

        //TODO: ADJUST AND FIX THIS TO MAKE IT REMOVE THE LAST THING IN QUEUE OR SOMETHING
        //if (this.activeNodeRequestCount > 100 && WorldEngine.getLevel(pos) < 2) {
            //Logger.info("Many active requests, declining request at " + WorldEngine.pprintPos(pos));
        //    this.invalidateNode(nodeId);
        //    return;
        //}





        //TODO:
        // Make it so that if a request is not in flight it has an invalid/null request entry

        // NOTE: inner nodes /w request should check they have geometry independenently of being inflight








        //TODO: FIXTHIS: https://discord.com/channels/973046939375505408/973046939375505411/1328785093812031489
        // this causes things to go bad, when racing the gpu, i.e. this becomes an inner node that has geometry and there is now a request for it
        // in this case we should not mark the node as inflight as it casuse very bad things to happen
        // we should only mark inflight when there is actually a request
        if (nodeType == NODE_TYPE_LEAF) {

            if (this.nodeData.getNodeGeometry(nodeId) == NULL_GEOMETRY_ID) {
                //Weird case that not sure how possible
                Logger.warn("Got request for leaf that doesnt have geometry, this should not be possible at pos " + WorldEngine.pprintPos(pos));
                if (!this.watcher.watch(pos, WorldEngine.UPDATE_TYPE_BLOCK_BIT)) {
                    Logger.warn("Node: " + nodeId + " at pos: " + WorldEngine.pprintPos(pos) + " got update request, but geometry was already being watched");
                }
                return;
            }

            //Check if the node is already in-flight, if it is, dont do any processing
            if (this.nodeData.isNodeRequestInFlight(nodeId)) {
                Logger.warn("Tried processing a node that already has a request in flight: " + nodeId + " pos: " + WorldEngine.pprintPos(pos) + " ignoring");
                return;
            }

            //Mark node as having an inflight request
            this.nodeData.markRequestInFlight(nodeId);

            //The hard one of processRequest, spin up a new request for the node
            this.makeLeafChildRequest(nodeId);

        } else {
            this.processInnerRequest(pos, nodeId);
        }
    }

    private void makeLeafChildRequest(int nodeId) {
        long pos = this.nodeData.nodePosition(nodeId);
        byte childExistence = this.nodeData.getNodeChildExistence(nodeId);

        if (childExistence == 0) {
            if (!this.topLevelNodes.contains(pos)) {//Top level nodes are special, as they can have a request with child existence of 0 for performance reasons
                Logger.warn("Not creating a leaf request with existence mask of 0 at pos", WorldEngine.pprintPos(pos));
                this.nodeData.unmarkRequestInFlight(nodeId);
                this.invalidateNode(nodeId);
                return;
            }
        }

        //Enqueue a leaf expansion request
        var request = new NodeChildRequest(pos);
        int requestId = this.childRequests.put(request);

        //Only request against the childExistence mask, since the guarantee is that if childExistence bit is not set then that child is guaranteed to be empty
        for (int i = 0; i < 8; i++) {
            if ((childExistence&(1<<i))==0) {
                //Dont watch or enqueue the child node cause it doesnt exist
                continue;
            }
            long childPos = makeChildPos(pos, i);
            request.addChildRequirement(i);

            //Insert all the children into the tracking map with the node id
            int pid = this.activeSectionMap.put(childPos, requestId|NODE_TYPE_REQUEST|REQUEST_TYPE_CHILD);

            if (pid != -1) {
                String extra = "";
                if ((pid&NODE_TYPE_MSK)==NODE_TYPE_LEAF) {
                    extra = " type leaf: pos " + WorldEngine.pprintPos( this.nodeData.nodePosition(pid)) + " hasRequest: " + this.nodeData.isNodeRequestInFlight(pid);
                }
                throw new IllegalStateException("Leaf request creation failed to insert child into map as a mapping already existed for the node! pos: " + WorldEngine.pprintPos(childPos) + " id: " + pid + " for parent " + WorldEngine.pprintPos(pos) + " extra " + extra);
            }

            //Watch and request the child node at the given position
            if (!this.watcher.watch(childPos, WorldEngine.DEFAULT_UPDATE_FLAGS)) {
                throw new IllegalStateException("Failed to watch childPos");
            }
        }

        this.nodeData.setNodeRequest(nodeId, requestId);
        this.activeNodeRequestCount++;
    }

    //A request is received for an inner node position
    private void processInnerRequest(long pos, int nodeId) {
        //TODO: finish
        int geo = this.nodeData.getNodeGeometry(nodeId);
        if (VERIFY_NODE_MANAGER_OPERATIONS) {
            boolean isWatchingUpdate = (this.watcher.get(pos)&UPDATE_TYPE_BLOCK_BIT)!=0;
            boolean inflight = this.nodeData.isNodeGeometryInFlight(nodeId);
            if (inflight && !isWatchingUpdate) {
                throw new IllegalStateException();//If we have geometry request inflight we must be watching
            }
            if (geo != NULL_GEOMETRY_ID && inflight) {
                //Having a EMPTY_GEOMETRY_ID and inflight is valid unfortunatly due to conditions when making an
                // inner node into a leaf node when child existance is set to zero and it has no geometry
                if (geo != EMPTY_GEOMETRY_ID)
                    throw new IllegalStateException();
            }
        }

        if (!this.nodeData.isNodeGeometryInFlight(nodeId)) {
            if (!this.watcher.watch(pos, WorldEngine.UPDATE_TYPE_BLOCK_BIT)) {
                //Logger.info("Node: " + nodeId + " at pos: " + WorldEngine.pprintPos(pos) + " got update request, but geometry was already being watched");
                this.invalidateNode(nodeId);//Who knows why but just invalidate the data just to keep in sync
            } else {
                this.nodeData.markNodeGeometryInFlight(nodeId);
            }
        }
    }
    //==================================================================================================================
    // Used by the cleaning system to ensure memory capacity in the geometry store

    //TODO: Think plan for this is to add new flag to NodeStore to indicate if geometry mesh request is inflight
    // this used for state verification and not emitting/assuming things
    // e.g. current issue is if an inner node wants/needs to convert into a leaf node, but the inner node has no geometry
    // how to deal with that?? e.g. inner node geometry gets cleared but then the childExistance gets set to 0
    // it needs to become a leaf node

    public void removeNodeGeometry(long pos) {
        int nodeId = this.activeSectionMap.get(pos);
        if (nodeId == -1) {
            //Logger.warn("Got geometry removal for pos " + WorldEngine.pprintPos(pos) + " but it was not in active map, ignoring!");
            return;
        }
        int nodeType = nodeId&NODE_TYPE_MSK;
        nodeId &= NODE_ID_MSK;
        if (nodeType == NODE_TYPE_REQUEST) {
            //TODO: only log a specific number of times
            //Logger.warn("Tried removing geometry for pos: " + WorldEngine.pprintPos(pos) + " but its type was a request, ignoring!");
            return;
        }
        //this.clearId(nodeId);

        if (nodeType == NODE_TYPE_INNER) {
            this.clearGeometryInternal(pos, nodeId);
        //    this.clearId(nodeId);
        } else {//NODE_TYPE_LEAF
            //TODO: here we need to make the parent node a leaf node...
            // TODO? think about maybe only doing it if all children of the parent are leaf nodes aswell

            if (this.topLevelNodes.contains(pos)) {
                //We are asked to remove the geometry of a top level leaf node, which we cannot do
                int geo = this.nodeData.getNodeGeometry(nodeId);
                if (geo == NULL_GEOMETRY_ID || geo == EMPTY_GEOMETRY_ID) {
                    //If its null or empty we can "ignore" the request
                } else {
                    Logger.warn("Tried removing geometry from top level node which is not allowed, disregarding request");
                    //TODO: probably do
                    //this.clearId(nodeId);
                    return;
                }

            } else {
                this.processLeafGeometryRemoval(pos);
            }
        }
    }

    private void processLeafGeometryRemoval(long cPos) {
        long pPos = makeParentPos(cPos);
        int pId = this.activeSectionMap.get(pPos);
        if (pId == -1) throw new IllegalStateException("Parent node must exist");
        if ((pId & NODE_TYPE_MSK) != NODE_TYPE_INNER)
            throw new IllegalStateException("Parent node must be an inner node");
        pId &= NODE_ID_MSK;

        if (false) {//Check all children are leaf nodes
            //TODO: make a better way to do this (i.e. gpu driven)
            int cPtr = this.nodeData.getChildPtr(pId);
            if (cPtr != SENTINEL_EMPTY_CHILD_PTR) {
                if (cPtr == -1) {
                    throw new IllegalStateException();
                }
                int cCnt = this.nodeData.getChildPtrCount(pId);
                for (int i = 0; i < cCnt; i++) {
                    if (!this.nodeData.nodeExists(i+cPtr))
                        throw new IllegalStateException();
                    long cp = this.nodeData.nodePosition(i+cPtr);
                    long cn = this.activeSectionMap.get(cp);
                    if (cn==-1)
                        throw new IllegalStateException();
                    //If a child is not a leaf, return
                    if ((cn&NODE_TYPE_MSK)!=NODE_TYPE_LEAF) {

                        this.clearAllocId(this.activeSectionMap.get(cPos)&NODE_ID_MSK);
                        return;
                    }
                }
            }
        }

        int pGeo = this.nodeData.getNodeGeometry(pId);
        if (pGeo == NULL_GEOMETRY_ID) {
            //We cannot make the parent a leaf node with null geometry
            this.processRequest(pPos);//Request geometry
        } else {
            //Convert to leaf node
            this.recurseRemoveChildNodes(pPos);//TODO: make this download/fetch the data instead of just deleting it
            //this.clearId(pId);

            //Make node a leaf
            int old = this.activeSectionMap.put(pPos, NODE_TYPE_LEAF|pId);
            if (old == -1)
                throw new IllegalStateException();
            if ((old&NODE_TYPE_MSK)!=NODE_TYPE_INNER || (old&NODE_ID_MSK)!=pId)
                throw new IllegalStateException();

            //Mark all children as not leaf (as this is a leaf node)
            this.nodeData.setAllChildrenAreLeaf(pId, false);
        }
    }

    private void clearGeometryInternal(long pos, int nodeId) {
        int meshId = this.nodeData.getNodeGeometry(nodeId);

        //TODO: if isNodeGeometryInFlight is true and geometryId == NULL_GEOMETRY_ID, probably need to
        // unwatch from watcher and unmark

        if (meshId != NULL_GEOMETRY_ID && meshId != EMPTY_GEOMETRY_ID) {
            //Unwatch node geometry changes
            if (this.watcher.unwatch(pos, WorldEngine.UPDATE_TYPE_BLOCK_BIT)) {
                throw new IllegalStateException("Unwatching position for geometry removal at: " + WorldEngine.pprintPos(pos) + " resulted in full removal");
            }
            //Remove geometry and set to null
            this.removeGeometryCached(pos, meshId);
            this.nodeData.setNodeGeometry(nodeId, NULL_GEOMETRY_ID);
            this.invalidateNode(nodeId);//Only need to invalidate on change
            this.nodeData.unmarkNodeGeometryInFlight(nodeId);//Remove geometry inflight as well, its removed
        } else {
            if (meshId == NULL_GEOMETRY_ID) {
                //Logger.info("Tried removing geometry of internal node but geometry was null");
            }
        }
    }

    //==================================================================================================================
    public boolean writeChanges(GlBuffer nodeBuffer) {
        //TODO: use like compute based copy system or something
        // since microcopies are bad
        if (this.nodeUpdates.isEmpty()) {
            return false;
        }
        this.nodeUpdates.forEach((int i) -> this.nodeData.writeNode(UploadStream.INSTANCE.upload(nodeBuffer, i*16L, 16L), i));
        this.nodeUpdates.clear();
        return true;
    }

    //Used for raw access to the update map, internal (used in async)
    IntOpenHashSet getNodeUpdates() {
        return this.nodeUpdates;
    }

    //Used to write a specified node into a specific address (used in async)
    void writeNode(int node, long address) {
        this.nodeData.writeNode(address, node);
    }

    public MemoryBuffer _generateChangeList() {
        //For internal testing use only
        if (this.nodeUpdates.isEmpty()) {
            return null;
        }
        var buff = new MemoryBuffer(this.nodeUpdates.size()*20L);
        int c = 0;
        for (int i : this.nodeUpdates) {
            long addr = buff.address + 20L * c++;
            MemoryUtil.memPutInt(addr, i);
            this.nodeData.writeNode(addr+4, i);
        }
        this.nodeUpdates.clear();
        return buff;
    }

    private void invalidateNode(int nodeId) {
        this.nodeUpdates.add(nodeId);
    }

    //==================================================================================================================
    private static int getChildIdx(long pos) {
        int x = WorldEngine.getX(pos);
        int y = WorldEngine.getY(pos);
        int z = WorldEngine.getZ(pos);
        return (x&1)|((y&1)<<2)|((z&1)<<1);
    }

    private static long makeChildPos(long basePos, int addin) {
        int lvl = WorldEngine.getLevel(basePos);
        if (lvl == 0) {
            throw new IllegalArgumentException("Cannot create a child lower than lod level 0");
        }
        return WorldEngine.getWorldSectionId(lvl-1,
                (WorldEngine.getX(basePos)<<1)|(addin&1),
                (WorldEngine.getY(basePos)<<1)|((addin>>2)&1),
                (WorldEngine.getZ(basePos)<<1)|((addin>>1)&1));
    }

    private long makeParentPos(long pos) {
        int lvl = WorldEngine.getLevel(pos);
        if (lvl == MAX_LOD_LAYER) {
            throw new IllegalArgumentException("Cannot create a parent higher than LoD " + (MAX_LOD_LAYER));
        }
        return WorldEngine.getWorldSectionId(lvl+1,
                WorldEngine.getX(pos)>>1,
                WorldEngine.getY(pos)>>1,
                WorldEngine.getZ(pos)>>1);
    }

    public void addDebug(List<String> debug) {
        debug.add("NC/IF: " + this.activeSectionMap.size() + "/" + (this.singleRequests.count() + this.childRequests.count()));
    }

    public int getCurrentMaxNodeId() {
        return this.nodeData.getEndNodeId();
    }


    //==================================================================================================================

    //TODO: need to figure out what happens if an inner node gets marked with child existence of 0
    // it should become a leaf node
    // however, if the node doesnt have geometry attached that would put it in an invalid state so need to figure out
    // a solution for this

    private int verifyRequest(long pos, int node, int cActiveExistence, LongOpenHashSet seenPositions, IntOpenHashSet seenNodes) {
        if (this.nodeData.isNodeRequestInFlight(node)) {
            int requestId = this.nodeData.getNodeRequest(node);
            var request = this.childRequests.get(requestId);//TODO: dont assume is a child request
            if (request.getPosition() != pos)
                throw new IllegalStateException();//Request position must be this position
            int reqMsk = Byte.toUnsignedInt(request.getMsk());
            if ((cActiveExistence&reqMsk)!=0)//Cannot have an active child and request for the same position
                throw new IllegalStateException();
            for (int i = 0; i < 8; i++) {
                if ((reqMsk&(1<<i))==0) continue;
                long cPos = makeChildPos(pos, i);
                int cNode = this.activeSectionMap.get(cPos);
                if (cNode == -1)//Request pos must be in map
                    throw new IllegalStateException();
                if ((cNode&NODE_TYPE_MSK)!=NODE_TYPE_REQUEST)//It must be a request type
                    throw new IllegalStateException();
                if ((cNode&REQUEST_TYPE_MSK)!=REQUEST_TYPE_CHILD)//Must be a child request
                    throw new IllegalStateException();
                if ((cNode&NODE_ID_MSK) != requestId)//Must be for this request
                    throw new IllegalStateException();
                this.verifyNode(cPos, seenPositions, seenNodes);
            }
            return reqMsk;
        }
        return 0;
    }

    private void verifyNode(long pos, LongOpenHashSet seenPositions, IntOpenHashSet seenNodes) {
        int node = this.activeSectionMap.get(pos);
        if (node == -1) {
            throw new IllegalStateException();
        }
        if (this.watcher.get(pos) == 0) {//Watcher must always be watching the node
            throw new IllegalStateException();
        }
        if (!seenPositions.add(pos))
            throw new IllegalStateException();

        int type = node&NODE_TYPE_MSK;
        if (type == NODE_TYPE_REQUEST) {
            if ((node&REQUEST_TYPE_MSK)==REQUEST_TYPE_SINGLE) {
                if (!this.topLevelNodes.contains(pos)) {
                    throw new IllegalStateException();
                }
                int id = node&NODE_ID_MSK;
                var req = this.singleRequests.get(id);
                if (req.getPosition() != pos) {
                    throw new IllegalStateException();
                }
                //TODO
            } else {
                int id = node&NODE_ID_MSK;
                var req = this.childRequests.get(id);
                if (req.getPosition() != makeParentPos(pos)) {
                    throw new IllegalStateException();
                }
                //TODO
            }
        } else {
            node &= NODE_ID_MSK;
            if (!this.nodeData.nodeExists(node)) {
                throw new IllegalStateException();
            }

            //if (type != this.nodeData.getNodeType(node))
            //    throw new IllegalStateException();

            if (this.nodeData.nodePosition(node) != pos) {
                throw new IllegalStateException();
            }
            if ((this.nodeData.getNodeRequest(node) != NULL_REQUEST_ID) != this.nodeData.isNodeRequestInFlight(node)) {
                throw new IllegalStateException();
            }
            if (this.nodeData.isNodeRequestInFlight(node)) {
                var req = this.childRequests.get(this.nodeData.getNodeRequest(node));
                if (req == null) {
                    throw new IllegalStateException();
                }
                if (req.getPosition() != pos) {
                    throw new IllegalStateException();
                }
                if (req.isSatisfied()) {//If a request is satisfied it should not be in the array
                    //The exception to this rule is the top level nodes, and only if they are leaf nodes
                    if (!(type == NODE_TYPE_LEAF && this.topLevelNodes.contains(pos)))
                        throw new IllegalStateException();
                }
            }

            {
                boolean hasGeometry = this.nodeData.getNodeGeometry(node) != NULL_GEOMETRY_ID;
                boolean watchingGeo = (this.watcher.get(pos)&UPDATE_TYPE_BLOCK_BIT)!=0;
                boolean awaitingGeo = this.nodeData.isNodeGeometryInFlight(node);
                //There must either be geometry or waiting for geometry if is watching
                if ((hasGeometry||awaitingGeo) != watchingGeo)
                    throw new IllegalStateException();
                //Cannot be awaiting geometry and have it
                if (hasGeometry && awaitingGeo) {
                    //We assume if the geometry is EMPTY, that what happened was an inner node just got convertex into a leaf node and is now awaiting its geometry
                    //if (type != NODE_TYPE_LEAF || this.nodeData.getNodeGeometry(node) != EMPTY_GEOMETRY_ID)
                    //    throw new IllegalStateException();
                    //HOWEVER, what can happen is that before we recieve the geometry for the node, thus clearing the geometryInFlight
                    // is that we get a request and childexistance change and all the children recieved,
                    // thus causing the node to become an INNER node again ;-;

                    //So just... sigh, just check that the geometry is not empty...
                    if (this.nodeData.getNodeGeometry(node) != EMPTY_GEOMETRY_ID)
                        throw new IllegalStateException();
                }
            }
            //if (this.nodeData.getNodeType(node) != type) {
            //    throw new IllegalStateException();
            //}
            if (!seenNodes.add(node))
                throw new IllegalStateException();
            if (type == NODE_TYPE_INNER) {
                int childPtr = this.nodeData.getChildPtr(node);
                int childCount = this.nodeData.getChildPtrCount(node);
                int cActiveExistence = 0;

                if (childPtr == -1) {//Inner nodes cannot have null child ptrs
                    throw new IllegalStateException();
                }
                //TODO: check SENTINEL_EMPTY_CHILD_PTR
                if (childPtr != SENTINEL_EMPTY_CHILD_PTR) {
                    boolean allChildrenLeaf = true;//childCount != 0;
                    for (int i = 0; i < childCount; i++) {
                        if (!this.nodeData.nodeExists(i + childPtr))//All children must exist
                            throw new IllegalStateException();
                        long cPos = this.nodeData.nodePosition(i + childPtr);
                        if (makeParentPos(cPos) != pos)//Parent of child must be this position
                            throw new IllegalStateException();
                        cActiveExistence |= 1 << getChildIdx(cPos);

                        int cNode = this.activeSectionMap.get(cPos);
                        if (cNode == -1) {
                            throw new IllegalStateException();
                        }
                        if ((cNode&NODE_TYPE_MSK) != NODE_TYPE_LEAF) {
                            allChildrenLeaf = false;
                        }
                        //Recurse into child
                        this.verifyNode(cPos, seenPositions, seenNodes);
                    }

                    if (this.nodeData.getAllChildrenAreLeaf(node) != allChildrenLeaf) {
                        throw new IllegalStateException();
                    }
                } else {
                    if (this.nodeData.getAllChildrenAreLeaf(node)) {
                        throw new IllegalStateException();
                    }
                    //TODO: verify SENTINEL_EMPTY_CHILD_PTR is valid
                    childCount = 0;
                }

                int childExistence = cActiveExistence;
                childExistence |= this.verifyRequest(pos, node, cActiveExistence, seenPositions, seenNodes);

                if (childExistence != Byte.toUnsignedInt(this.nodeData.getNodeChildExistence(node))) {
                    throw new IllegalStateException();
                }

                if (childExistence == 0) {//Inner nodes should always have children
                    throw new IllegalStateException();
                }
            } else if (type == NODE_TYPE_LEAF) {
                if (this.nodeData.getAllChildrenAreLeaf(node)) {
                    throw new IllegalStateException();
                }

                if (this.nodeData.getChildPtr(node) != -1) {//Leafs cannot have child ptrs
                    throw new IllegalStateException();
                }

                if (this.nodeData.getNodeGeometry(node) == NULL_GEOMETRY_ID) {//Leafs cannot have null geometry
                    throw new IllegalStateException();
                }

                if (WorldEngine.getLevel(pos) == 0) {
                    //TODO: this is a specialcase
                    if (this.nodeData.isNodeRequestInFlight(node)) {//Child nodes cannot have inflight requests
                        throw new IllegalStateException();
                    }
                } else {
                    //Child existence only matters if there is a request in flight
                    if (this.nodeData.isNodeRequestInFlight(node)) {
                        int childExistence = this.verifyRequest(pos, node, 0, seenPositions, seenNodes);
                        if (childExistence != Byte.toUnsignedInt(this.nodeData.getNodeChildExistence(node))) {
                            throw new IllegalStateException();
                        }
                    }
                }
                //TODO

            } else {
                throw new IllegalStateException();
            }
        }
    }

    public void verifyIntegrity() {
        this.verifyIntegrity(null, null);
    }
    public void verifyIntegrity(LongSet watchingPosSet, IntSet nodes) {
        //Should verify integrity of node manager, everything
        // should traverse from top (root positions) down
        // after it should check if there is anything it hasnt tracked, if so thats badd
        //It should check childPtr and childPtrCount match and align with the nodeMsk
        // verify requests and positions
        //it should verify everything is correct and as it should be
        // it should verify geometry exists as well for nodes that should

        LongOpenHashSet seenPositions = new LongOpenHashSet();
        IntOpenHashSet seenNodes = new IntOpenHashSet();

        for (long pos : this.topLevelNodes) {
            this.verifyNode(pos, seenPositions, seenNodes);
        }

        var thisMap = this.activeSectionMap.keySet();
        if (!(seenPositions.containsAll(thisMap)&&thisMap.containsAll(seenPositions))) {
            throw new IllegalStateException();
        }

        if (seenNodes.size() != this.nodeData.getNodeCount()) {
            throw new IllegalStateException();
        }
        for (int i : seenNodes) {
            if (!this.nodeData.nodeExists(i)) {
                throw new IllegalStateException();
            }
        }
        if (this.activeNodeRequestCount != this.childRequests.count()) {
            throw new IllegalStateException();
        }
        if (watchingPosSet != null) {
            if (!watchingPosSet.containsAll(thisMap)) {
                throw new IllegalStateException();
            }
            if (!thisMap.containsAll(watchingPosSet)) {
                throw new IllegalStateException();
            }
        }
        if (nodes != null) {
            if (!nodes.containsAll(seenNodes)) {
                throw new IllegalStateException();
            }
            if (!seenNodes.containsAll(nodes)) {
                throw new IllegalStateException();
            }
        }

        IntSet tln = new IntOpenHashSet(this.topLevelNodeIds.size());
        for (long p : this.topLevelNodes) {
            int n = this.activeSectionMap.get(p);
            if (n == -1) {
                throw new IllegalStateException();
            }
            if ((n&NODE_TYPE_MSK)!=NODE_TYPE_REQUEST) {
                if (!tln.add(n&NODE_ID_MSK)) {
                    throw new IllegalStateException();
                }
            }
        }

        if (!this.topLevelNodeIds.containsAll(tln)) {
            throw new IllegalStateException();
        }

        if (!tln.containsAll(this.topLevelNodeIds)) {
            throw new IllegalStateException();
        }
    }
}
